//go:build go1.22

// Package acp_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package acp_api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AgentConnectProtocolType.
const (
	ACP AgentConnectProtocolType = "ACP"
)

// Defines values for CustomRunResultUpdateType.
const (
	CustomRunResultUpdateTypeCustom CustomRunResultUpdateType = "custom"
)

// Defines values for DockerDeploymentType.
const (
	Docker DockerDeploymentType = "docker"
)

// Defines values for LangGraphConfigFrameworkType.
const (
	Langgraph LangGraphConfigFrameworkType = "langgraph"
)

// Defines values for LlamaIndexConfigFrameworkType.
const (
	Llamaindex LlamaIndexConfigFrameworkType = "llamaindex"
)

// Defines values for RemoteServiceDeploymentType.
const (
	RemoteService RemoteServiceDeploymentType = "remote_service"
)

// Defines values for RunErrorType.
const (
	RunErrorTypeError RunErrorType = "error"
)

// Defines values for RunInterruptType.
const (
	Interrupt RunInterruptType = "interrupt"
)

// Defines values for RunOutputStreamEvent.
const (
	AgentEvent RunOutputStreamEvent = "agent_event"
)

// Defines values for RunResultType.
const (
	Result RunResultType = "result"
)

// Defines values for RunStatus.
const (
	RunStatusError       RunStatus = "error"
	RunStatusInterrupted RunStatus = "interrupted"
	RunStatusPending     RunStatus = "pending"
	RunStatusSuccess     RunStatus = "success"
	RunStatusTimeout     RunStatus = "timeout"
)

// Defines values for SourceCodeDeploymentType.
const (
	SourceCode SourceCodeDeploymentType = "source_code"
)

// Defines values for StreamingMode.
const (
	StreamingModeCustom StreamingMode = "custom"
	StreamingModeResult StreamingMode = "result"
)

// Agent A description of an agent supported by this server
type Agent struct {
	// AgentId Unique identifier of the agent in this server.
	AgentId openapi_types.UUID `json:"agent_id"`

	// Metadata Basic information associated to the agent
	Metadata AgentMetadata `json:"metadata"`
}

// AgentConnectProtocol ACP endpoint description
type AgentConnectProtocol struct {
	// AgentId Agent identifier in ACP server. If missing, the first returned agent with matching name and version should be used.
	AgentId *openapi_types.UUID `json:"agent_id,omitempty"`

	// Authentication This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#security-scheme-object-0
	Authentication *SecurityScheme          `json:"authentication,omitempty"`
	Type           AgentConnectProtocolType `json:"type"`

	// Url URL pointing to the ACP endpoint root.
	Url string `json:"url"`
}

// AgentConnectProtocolType defines model for AgentConnectProtocol.Type.
type AgentConnectProtocolType string

// AgentManifest Describe all the details of an agent, including how to use, how to deploy and its dependencies.
type AgentManifest struct {
	// Dependencies List of all other agents this agent depends on
	Dependencies *[]AgentManifestRef `json:"dependencies,omitempty"`

	// Deployments List of possible methods to instantiate or consume the agent.  Any of the available option could be used.
	// Every option could be associated with a unique name within this agent. If present, when another manifest refers to this manifest, it can also select the preferred deployment option.
	Deployments *[]AgentManifest_Deployments_Item `json:"deployments,omitempty"`

	// Metadata Basic information associated to the agent
	Metadata AgentMetadata `json:"metadata"`

	// Specs Specification of agent capabilities, config, input, output, and interrupts
	Specs struct {
		// Capabilities Declares what invocation features this agent is capable of.
		Capabilities struct {
			// Callbacks This is `true` if the agent supports a webhook to report run results. If this is `false`, providing a `webhook` at run creation has no effect. If missing, it means `false`
			Callbacks *bool `json:"callbacks,omitempty"`

			// Interrupts This is `true` if the agent runs can interrupt to request additional input and can be subsequently resumed. If missing, it means `false`
			Interrupts *bool `json:"interrupts,omitempty"`

			// Streaming Supported streaming modes. If missing, streaming is not supported.  If no mode is supported attempts to stream output will result in an error.
			Streaming *struct {
				// Custom This is `true` if the agent supports custom objects streaming. If `false` or missing, custom streaming is not supported. Custom Objects streaming consists of a stream of object whose schema is specified by the agent in its manifest under `specs.custom_streaming_update`.
				Custom *bool `json:"custom,omitempty"`

				// Result This is `true` if the agent supports result streaming. If `false` or missing, result streaming is not supported. Result streaming consists of a stream of objects of type `RunResult`, where each one sent over the stream fully replace the previous one.
				Result *bool `json:"result,omitempty"`
			} `json:"streaming,omitempty"`

			// Threads This is `true` if the agent supports run threads. If this is `false`, then the threads tagged with `Threads` are not available. If missing, it means `false`
			Threads *bool `json:"threads,omitempty"`
		} `json:"capabilities"`

		// Config This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object
		Config map[string]interface{} `json:"config"`

		// CustomStreamingUpdate This describes the format of an Update in the streaming.  Must be specified if `streaming.custom` capability is true and cannot be specified otherwise. Format follows: https://spec.openapis.org/oas/v3.1.1.html#schema-object
		CustomStreamingUpdate *map[string]interface{} `json:"custom_streaming_update,omitempty"`

		// Input This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object
		Input map[string]interface{} `json:"input"`

		// Interrupts List of possible interrupts that can be provided by the agent. If `interrupts` capability is true, this needs to have at least one item.
		Interrupts *[]struct {
			// InterruptPayload This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object
			InterruptPayload map[string]interface{} `json:"interrupt_payload"`

			// InterruptType Name of this interrupt type. Needs to be unique in the list of interrupts.
			InterruptType string `json:"interrupt_type"`

			// ResumePayload This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object
			ResumePayload map[string]interface{} `json:"resume_payload"`
		} `json:"interrupts,omitempty"`

		// Output This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object
		Output map[string]interface{} `json:"output"`

		// ThreadState This describes the format of ThreadState.  Cannot be specified if `threads` capability is false. If not specified, when `threads` capability is true, then the API to retrieve ThreadState from a Thread or a Run is not available. This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object
		ThreadState *map[string]interface{} `json:"thread_state,omitempty"`
	} `json:"specs"`
}

// AgentManifest_Deployments_Item defines model for AgentManifest.deployments.Item.
type AgentManifest_Deployments_Item struct {
	union json.RawMessage
}

// AgentManifestRef Reference to an Agent Manifest, it includes name, version and a locator.
type AgentManifestRef struct {
	// Name Name of the agent that identifies the agent in its manifest
	Name string `json:"name"`

	// Url URL of the manifest. Can be a network location or a file.
	Url *string `json:"url,omitempty"`

	// Version Version of the agent in its manifest. Should be formatted according to semantic versioning (https://semver.org)
	Version string `json:"version"`
}

// AgentMetadata Basic information associated to the agent
type AgentMetadata struct {
	// Description Description of this agent, which should include what the intended use is, what tasks it accomplishes and how uses input and configs to produce the output and any other side effect
	Description string `json:"description"`

	// Ref Reference to an Agent Manifest, it includes name, version and a locator.
	Ref AgentManifestRef `json:"ref"`
}

// AgentSearchRequest Payload for listing agents.
type AgentSearchRequest struct {
	// Limit Maximum number to return.
	Limit *int `json:"limit,omitempty"`

	// Name Match all agents with the name specified.
	Name *string `json:"name,omitempty"`

	// Offset Offset to start from.
	Offset *int `json:"offset,omitempty"`

	// Version Match all agents with the version specified. Formatted according to semantic versioning (https://semver.org)
	Version *string `json:"version,omitempty"`
}

// ConfigSchema The configuration for this agent. The schema is described in Agent Manifest under 'spec.config'. If missing, default values are used.
type ConfigSchema = map[string]interface{}

// CustomRunResultUpdate Object holding a custom defined update of the agent result during streaming.
type CustomRunResultUpdate struct {
	// RunId The ID of the run.
	RunId  openapi_types.UUID        `json:"run_id"`
	Status RunStatus                 `json:"status"`
	Type   CustomRunResultUpdateType `json:"type"`

	// Update An update in the SSE event streaming where streaming mode is set to custom. The schema is described in Agent Manifest under 'spec.custom_streaming_update'.
	Update StreamUpdateSchema `json:"update"`
}

// CustomRunResultUpdateType defines model for CustomRunResultUpdate.Type.
type CustomRunResultUpdateType string

// DockerDeployment Describes the docker deployment for this agent
type DockerDeployment struct {
	// Image Container image for the agent
	Image string `json:"image"`

	// Protocol ACP endpoint description
	Protocol AgentConnectProtocol `json:"protocol"`
	Type     DockerDeploymentType `json:"type"`
}

// DockerDeploymentType defines model for DockerDeployment.Type.
type DockerDeploymentType string

// ErrorResponse Error message returned from the server
type ErrorResponse = string

// InputSchema The input to the agent. The schema is described in Agent Manifest under 'spec.thread_state'.'input'.
type InputSchema = map[string]interface{}

// InterruptPayloadSchema This schema describes the interrupt payload. Actual schema describes a polimorphic object, which means a schema structured with `oneOf` and `discriminator`. The discriminator is the `interrupt_type`, while the schemas will be the ones defined in the agent spec under `interrupts`/`interrupt_payload` For example:          oneOf:
//   - $ref: '#/components/schemas/ApprovalInterruptPayload'
//   - $ref: '#/components/schemas/QuestionInterruptPayload'
//
// discriminator:
//
//	propertyName: interruput_type
//	mapping:
//	  approval: '#/components/schemas/ApprovalInterruptPayload'
//	  question: '#/components/schemas/QuestionInterruptPayload'
type InterruptPayloadSchema = map[string]interface{}

// LangGraphConfig Describes langgraph based agent deployment config
type LangGraphConfig struct {
	FrameworkType LangGraphConfigFrameworkType `json:"framework_type"`
	Graph         string                       `json:"graph"`
}

// LangGraphConfigFrameworkType defines model for LangGraphConfig.FrameworkType.
type LangGraphConfigFrameworkType string

// LlamaIndexConfig Describes llamaindex based agent deployment config
type LlamaIndexConfig struct {
	FrameworkType LlamaIndexConfigFrameworkType `json:"framework_type"`
	Path          string                        `json:"path"`
}

// LlamaIndexConfigFrameworkType defines model for LlamaIndexConfig.FrameworkType.
type LlamaIndexConfigFrameworkType string

// OutputSchema The output of the agent. The schema is described in Agent Manifest under 'spec.output'.
type OutputSchema = map[string]interface{}

// RemoteServiceDeployment Describes the network endpoint where the agent is available
type RemoteServiceDeployment struct {
	// Protocol ACP endpoint description
	Protocol AgentConnectProtocol        `json:"protocol"`
	Type     RemoteServiceDeploymentType `json:"type"`
}

// RemoteServiceDeploymentType defines model for RemoteServiceDeployment.Type.
type RemoteServiceDeploymentType string

// ResumePayloadSchema This schema describes the resume payload after an interrupt. Actual schema describes a polimorphic object, which means a schema structured with `oneOf` and `discriminator`. The discriminator is the `interrupt_type`, while the schemas will be those defined in the agent spec under `interrupts`/`resume_payload` For example:          oneOf:
//   - $ref: '#/components/schemas/ApprovalResumePayload'
//   - $ref: '#/components/schemas/QuestionResumePayload'
//
// discriminator:
//
//	propertyName: interrupt_type
//	mapping:
//	  approval: '#/components/schemas/ApprovalResumePayload'
//	  question: '#/components/schemas/QuestionResumePayload'
type ResumePayloadSchema = map[string]interface{}

// Run Holds all the information of a run
type Run struct {
	// AgentId The agent that was used for this run.
	AgentId openapi_types.UUID `json:"agent_id"`

	// CreatedAt The time the run was created.
	CreatedAt time.Time `json:"created_at"`

	// Creation Payload for creating a run.
	Creation RunCreate `json:"creation"`

	// RunId The ID of the run.
	RunId  openapi_types.UUID `json:"run_id"`
	Status RunStatus          `json:"status"`

	// ThreadId Optional Thread ID wher the Run belongs to. This is populated only for runs on agents agents supporting Threads.
	ThreadId *openapi_types.UUID `json:"thread_id,omitempty"`

	// UpdatedAt The last time the run was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// RunCreate Payload for creating a run.
type RunCreate struct {
	// AgentId The ID of the agent.
	AgentId openapi_types.UUID `json:"agent_id"`

	// Config The configuration for this agent. The schema is described in Agent Manifest under 'spec.config'. If missing, default values are used.
	Config *ConfigSchema `json:"config,omitempty"`

	// Input The input to the agent. The schema is described in Agent Manifest under 'spec.thread_state'.'input'.
	Input *InputSchema `json:"input,omitempty"`

	// Metadata Metadata to assign to the run. Optional free format metadata to attach to the run.
	Metadata  *map[string]interface{} `json:"metadata,omitempty"`
	Streaming *StreamingMode          `json:"streaming,omitempty"`

	// ThreadId Optional Thread ID wher the Run belongs to. This can be used only for agents supporting Threads.
	ThreadId *openapi_types.UUID `json:"thread_id,omitempty"`

	// Webhook Webhook to call upon change of run status. This is a url that accepts a POST containing the `Run` object as body. See Callbacks definition.
	Webhook *string `json:"webhook,omitempty"`
}

// RunError Run terminated with an error
type RunError struct {
	// Description description of the error
	Description string `json:"description"`

	// Errcode code of the error
	Errcode int `json:"errcode"`

	// RunId The ID of the run.
	RunId openapi_types.UUID `json:"run_id"`
	Type  RunErrorType       `json:"type"`
}

// RunErrorType defines model for RunError.Type.
type RunErrorType string

// RunInterrupt Interrupt occurred during a Run
type RunInterrupt struct {
	// Interrupt This schema describes the interrupt payload. Actual schema describes a polimorphic object, which means a schema structured with `oneOf` and `discriminator`. The discriminator is the `interrupt_type`, while the schemas will be the ones defined in the agent spec under `interrupts`/`interrupt_payload` For example:          oneOf:
	//   - $ref: '#/components/schemas/ApprovalInterruptPayload'
	//   - $ref: '#/components/schemas/QuestionInterruptPayload'
	// discriminator:
	//   propertyName: interruput_type
	//   mapping:
	//     approval: '#/components/schemas/ApprovalInterruptPayload'
	//     question: '#/components/schemas/QuestionInterruptPayload'
	Interrupt InterruptPayloadSchema `json:"interrupt"`
	Type      RunInterruptType       `json:"type"`
}

// RunInterruptType defines model for RunInterrupt.Type.
type RunInterruptType string

// RunOutput Output of a Run. Can be the final result or an interrupt.
type RunOutput struct {
	union json.RawMessage
}

// RunOutputStream Server-sent event containing one agent output event. Actual event type is carried inside the data.
type RunOutputStream struct {
	// Data A serialized JSON data structure carried in the SSE event data field. The event can carry either a full `RunResult`, if streaming mode is `result` or an custom update if streaming mode is `custom`
	Data RunOutputStream_Data `json:"data"`

	// Event Event type. This is the constant string `agent_event` to be compatible with SSE spec. The actual type differentiation is done in the event itself.
	Event RunOutputStreamEvent `json:"event"`

	// Id Unique identifier of the event
	Id string `json:"id"`
}

// RunOutputStream_Data A serialized JSON data structure carried in the SSE event data field. The event can carry either a full `RunResult`, if streaming mode is `result` or an custom update if streaming mode is `custom`
type RunOutputStream_Data struct {
	union json.RawMessage
}

// RunOutputStreamEvent Event type. This is the constant string `agent_event` to be compatible with SSE spec. The actual type differentiation is done in the event itself.
type RunOutputStreamEvent string

// RunResult Final result of a Run.
type RunResult struct {
	// Result The output of the agent. The schema is described in Agent Manifest under 'spec.output'.
	Result OutputSchema `json:"result"`

	// RunId The ID of the run.
	RunId  openapi_types.UUID `json:"run_id"`
	Status RunStatus          `json:"status"`
	Type   RunResultType      `json:"type"`
}

// RunResultType defines model for RunResult.Type.
type RunResultType string

// RunSearchRequest Payload for listing runs.
type RunSearchRequest struct {
	// AgentId Matches all the Runs associated with the specified Agent ID.
	AgentId *openapi_types.UUID `json:"agent_id,omitempty"`

	// Limit Maximum number to return.
	Limit *int `json:"limit,omitempty"`

	// Metadata Matches all threads for which metadata has  keys and values equal to those specified in this object.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Offset Offset to start from.
	Offset *int       `json:"offset,omitempty"`
	Status *RunStatus `json:"status,omitempty"`
}

// RunStatus defines model for RunStatus.
type RunStatus string

// SecurityScheme This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#security-scheme-object-0
type SecurityScheme = map[string]interface{}

// SourceCodeDeployment Describes the source code where the agent is available. It specifies also the type of deployer that it supports.
type SourceCodeDeployment struct {
	FrameworkConfig SourceCodeDeployment_FrameworkConfig `json:"framework_config"`

	// Name Name this deployment option is referred to within this agent. This is needed to indicate which one is preferred when this manifest is referred. Can be omitted, in such case selection is not possible.
	Name *string                  `json:"name,omitempty"`
	Type SourceCodeDeploymentType `json:"type"`

	// Url Location of the source code. E.g. path to code root, github repo url etc.
	Url string `json:"url"`
}

// SourceCodeDeployment_FrameworkConfig defines model for SourceCodeDeployment.FrameworkConfig.
type SourceCodeDeployment_FrameworkConfig struct {
	union json.RawMessage
}

// SourceCodeDeploymentType defines model for SourceCodeDeployment.Type.
type SourceCodeDeploymentType string

// StreamUpdateSchema An update in the SSE event streaming where streaming mode is set to custom. The schema is described in Agent Manifest under 'spec.custom_streaming_update'.
type StreamUpdateSchema = map[string]interface{}

// StreamingMode defines model for StreamingMode.
type StreamingMode string

// Thread Represents a collection of consecutive runs on an agent. Thread is associated with a state
type Thread struct {
	// AgentId Identifier of the agent this thread is executed on
	AgentId string `json:"agent_id"`

	// Metadata Free form metadata for this thread
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ThreadId unique identifier of a thread
	ThreadId string `json:"thread_id"`
}

// ThreadCreate Detail of an empty thread to be created.
type ThreadCreate struct {
	// AgentId Identifier of the agent this thread is executed on
	AgentId string `json:"agent_id"`

	// Metadata Free form metadata for this thread
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// ThreadSearchRequest Payload for listing runs.
type ThreadSearchRequest struct {
	// AgentId Matches all threads associated with the specified agent ID.
	AgentId *openapi_types.UUID `json:"agent_id,omitempty"`

	// Limit Maximum number to return.
	Limit *int `json:"limit,omitempty"`

	// Metadata Matches all threads for which metadata has  keys and values equal to those specified in this object.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Offset Offset to start from.
	Offset *int `json:"offset,omitempty"`
}

// ThreadStateSchema The thread state. The schema is described in Agent Manifest under 'spec.thread_state'.
type ThreadStateSchema = map[string]interface{}

// GetRunOutputParams defines parameters for GetRunOutput.
type GetRunOutputParams struct {
	BlockTimeout *int `form:"block_timeout,omitempty" json:"block_timeout,omitempty"`
}

// SearchAgentsJSONRequestBody defines body for SearchAgents for application/json ContentType.
type SearchAgentsJSONRequestBody = AgentSearchRequest

// CreateRunJSONRequestBody defines body for CreateRun for application/json ContentType.
type CreateRunJSONRequestBody = RunCreate

// SearchRunsJSONRequestBody defines body for SearchRuns for application/json ContentType.
type SearchRunsJSONRequestBody = RunSearchRequest

// ResumeRunJSONRequestBody defines body for ResumeRun for application/json ContentType.
type ResumeRunJSONRequestBody = ResumePayloadSchema

// CreateThreadJSONRequestBody defines body for CreateThread for application/json ContentType.
type CreateThreadJSONRequestBody = ThreadCreate

// SearchThreadsJSONRequestBody defines body for SearchThreads for application/json ContentType.
type SearchThreadsJSONRequestBody = ThreadSearchRequest

// AsSourceCodeDeployment returns the union data inside the AgentManifest_Deployments_Item as a SourceCodeDeployment
func (t AgentManifest_Deployments_Item) AsSourceCodeDeployment() (SourceCodeDeployment, error) {
	var body SourceCodeDeployment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSourceCodeDeployment overwrites any union data inside the AgentManifest_Deployments_Item as the provided SourceCodeDeployment
func (t *AgentManifest_Deployments_Item) FromSourceCodeDeployment(v SourceCodeDeployment) error {
	v.Type = "source_code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSourceCodeDeployment performs a merge with any union data inside the AgentManifest_Deployments_Item, using the provided SourceCodeDeployment
func (t *AgentManifest_Deployments_Item) MergeSourceCodeDeployment(v SourceCodeDeployment) error {
	v.Type = "source_code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoteServiceDeployment returns the union data inside the AgentManifest_Deployments_Item as a RemoteServiceDeployment
func (t AgentManifest_Deployments_Item) AsRemoteServiceDeployment() (RemoteServiceDeployment, error) {
	var body RemoteServiceDeployment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoteServiceDeployment overwrites any union data inside the AgentManifest_Deployments_Item as the provided RemoteServiceDeployment
func (t *AgentManifest_Deployments_Item) FromRemoteServiceDeployment(v RemoteServiceDeployment) error {
	v.Type = "remote_service"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoteServiceDeployment performs a merge with any union data inside the AgentManifest_Deployments_Item, using the provided RemoteServiceDeployment
func (t *AgentManifest_Deployments_Item) MergeRemoteServiceDeployment(v RemoteServiceDeployment) error {
	v.Type = "remote_service"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerDeployment returns the union data inside the AgentManifest_Deployments_Item as a DockerDeployment
func (t AgentManifest_Deployments_Item) AsDockerDeployment() (DockerDeployment, error) {
	var body DockerDeployment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerDeployment overwrites any union data inside the AgentManifest_Deployments_Item as the provided DockerDeployment
func (t *AgentManifest_Deployments_Item) FromDockerDeployment(v DockerDeployment) error {
	v.Type = "docker"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerDeployment performs a merge with any union data inside the AgentManifest_Deployments_Item, using the provided DockerDeployment
func (t *AgentManifest_Deployments_Item) MergeDockerDeployment(v DockerDeployment) error {
	v.Type = "docker"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentManifest_Deployments_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AgentManifest_Deployments_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "docker":
		return t.AsDockerDeployment()
	case "remote_service":
		return t.AsRemoteServiceDeployment()
	case "source_code":
		return t.AsSourceCodeDeployment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AgentManifest_Deployments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentManifest_Deployments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunResult returns the union data inside the RunOutput as a RunResult
func (t RunOutput) AsRunResult() (RunResult, error) {
	var body RunResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunResult overwrites any union data inside the RunOutput as the provided RunResult
func (t *RunOutput) FromRunResult(v RunResult) error {
	v.Type = "result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunResult performs a merge with any union data inside the RunOutput, using the provided RunResult
func (t *RunOutput) MergeRunResult(v RunResult) error {
	v.Type = "result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunInterrupt returns the union data inside the RunOutput as a RunInterrupt
func (t RunOutput) AsRunInterrupt() (RunInterrupt, error) {
	var body RunInterrupt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunInterrupt overwrites any union data inside the RunOutput as the provided RunInterrupt
func (t *RunOutput) FromRunInterrupt(v RunInterrupt) error {
	v.Type = "interrupt"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunInterrupt performs a merge with any union data inside the RunOutput, using the provided RunInterrupt
func (t *RunOutput) MergeRunInterrupt(v RunInterrupt) error {
	v.Type = "interrupt"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunError returns the union data inside the RunOutput as a RunError
func (t RunOutput) AsRunError() (RunError, error) {
	var body RunError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunError overwrites any union data inside the RunOutput as the provided RunError
func (t *RunOutput) FromRunError(v RunError) error {
	v.Type = "error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunError performs a merge with any union data inside the RunOutput, using the provided RunError
func (t *RunOutput) MergeRunError(v RunError) error {
	v.Type = "error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunOutput) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RunOutput) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "error":
		return t.AsRunError()
	case "interrupt":
		return t.AsRunInterrupt()
	case "result":
		return t.AsRunResult()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RunOutput) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunOutput) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunResult returns the union data inside the RunOutputStream_Data as a RunResult
func (t RunOutputStream_Data) AsRunResult() (RunResult, error) {
	var body RunResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunResult overwrites any union data inside the RunOutputStream_Data as the provided RunResult
func (t *RunOutputStream_Data) FromRunResult(v RunResult) error {
	v.Type = "result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunResult performs a merge with any union data inside the RunOutputStream_Data, using the provided RunResult
func (t *RunOutputStream_Data) MergeRunResult(v RunResult) error {
	v.Type = "result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomRunResultUpdate returns the union data inside the RunOutputStream_Data as a CustomRunResultUpdate
func (t RunOutputStream_Data) AsCustomRunResultUpdate() (CustomRunResultUpdate, error) {
	var body CustomRunResultUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomRunResultUpdate overwrites any union data inside the RunOutputStream_Data as the provided CustomRunResultUpdate
func (t *RunOutputStream_Data) FromCustomRunResultUpdate(v CustomRunResultUpdate) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomRunResultUpdate performs a merge with any union data inside the RunOutputStream_Data, using the provided CustomRunResultUpdate
func (t *RunOutputStream_Data) MergeCustomRunResultUpdate(v CustomRunResultUpdate) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunOutputStream_Data) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RunOutputStream_Data) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "custom":
		return t.AsCustomRunResultUpdate()
	case "result":
		return t.AsRunResult()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RunOutputStream_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunOutputStream_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLangGraphConfig returns the union data inside the SourceCodeDeployment_FrameworkConfig as a LangGraphConfig
func (t SourceCodeDeployment_FrameworkConfig) AsLangGraphConfig() (LangGraphConfig, error) {
	var body LangGraphConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLangGraphConfig overwrites any union data inside the SourceCodeDeployment_FrameworkConfig as the provided LangGraphConfig
func (t *SourceCodeDeployment_FrameworkConfig) FromLangGraphConfig(v LangGraphConfig) error {
	v.FrameworkType = "langgraph"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLangGraphConfig performs a merge with any union data inside the SourceCodeDeployment_FrameworkConfig, using the provided LangGraphConfig
func (t *SourceCodeDeployment_FrameworkConfig) MergeLangGraphConfig(v LangGraphConfig) error {
	v.FrameworkType = "langgraph"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLlamaIndexConfig returns the union data inside the SourceCodeDeployment_FrameworkConfig as a LlamaIndexConfig
func (t SourceCodeDeployment_FrameworkConfig) AsLlamaIndexConfig() (LlamaIndexConfig, error) {
	var body LlamaIndexConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLlamaIndexConfig overwrites any union data inside the SourceCodeDeployment_FrameworkConfig as the provided LlamaIndexConfig
func (t *SourceCodeDeployment_FrameworkConfig) FromLlamaIndexConfig(v LlamaIndexConfig) error {
	v.FrameworkType = "llamaindex"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLlamaIndexConfig performs a merge with any union data inside the SourceCodeDeployment_FrameworkConfig, using the provided LlamaIndexConfig
func (t *SourceCodeDeployment_FrameworkConfig) MergeLlamaIndexConfig(v LlamaIndexConfig) error {
	v.FrameworkType = "llamaindex"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SourceCodeDeployment_FrameworkConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"framework_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SourceCodeDeployment_FrameworkConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "langgraph":
		return t.AsLangGraphConfig()
	case "llamaindex":
		return t.AsLlamaIndexConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SourceCodeDeployment_FrameworkConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SourceCodeDeployment_FrameworkConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Search Agents
	// (POST /agents/search)
	SearchAgents(w http.ResponseWriter, r *http.Request)
	// Get Agent
	// (GET /agents/{agent_id})
	GetAgentByID(w http.ResponseWriter, r *http.Request, agentId openapi_types.UUID)
	// Get Agent Manifest from its id
	// (GET /agents/{agent_id}/manifest)
	GetAgentManifestById(w http.ResponseWriter, r *http.Request, agentId openapi_types.UUID)
	// Create Background Run
	// (POST /runs)
	CreateRun(w http.ResponseWriter, r *http.Request)
	// Search Runs
	// (POST /runs/search)
	SearchRuns(w http.ResponseWriter, r *http.Request)
	// Delete a run. If running, cancel and then delete.
	// (DELETE /runs/{run_id})
	DeleteRun(w http.ResponseWriter, r *http.Request, runId openapi_types.UUID)
	// Get a previously created Run
	// (GET /runs/{run_id})
	GetRun(w http.ResponseWriter, r *http.Request, runId openapi_types.UUID)
	// Resume an interrupted Run
	// (POST /runs/{run_id})
	ResumeRun(w http.ResponseWriter, r *http.Request, runId openapi_types.UUID)
	// Retrieve last output of a run if available
	// (GET /runs/{run_id}/output)
	GetRunOutput(w http.ResponseWriter, r *http.Request, runId openapi_types.UUID, params GetRunOutputParams)
	// Stream the run output
	// (GET /runs/{run_id}/stream)
	GetRunStream(w http.ResponseWriter, r *http.Request, runId openapi_types.UUID)
	// Retrieve the thread state at the end of the run
	// (GET /runs/{run_id}/threadstate)
	GetRunThreadstate(w http.ResponseWriter, r *http.Request, runId openapi_types.UUID)
	// Create an empty Thread
	// (POST /threads)
	CreateThread(w http.ResponseWriter, r *http.Request)
	// Search Threads
	// (POST /threads/search)
	SearchThreads(w http.ResponseWriter, r *http.Request)
	// Delete a thread. If the thread contains any pending run, deletion fails.
	// (DELETE /threads/{thread_id})
	DeleteThread(w http.ResponseWriter, r *http.Request, threadId openapi_types.UUID)
	// Get a previously created Thread
	// (GET /threads/{thread_id})
	GetThread(w http.ResponseWriter, r *http.Request, threadId openapi_types.UUID)
	// Retrieve the list of runs and associated state at the end of each run.
	// (GET /threads/{thread_id}/history)
	GetThreadHistory(w http.ResponseWriter, r *http.Request, threadId openapi_types.UUID)
	// Retrieve the current state associated with the thread
	// (GET /threads/{thread_id}/state)
	GetThreadState(w http.ResponseWriter, r *http.Request, threadId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// SearchAgents operation middleware
func (siw *ServerInterfaceWrapper) SearchAgents(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchAgents(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAgentByID operation middleware
func (siw *ServerInterfaceWrapper) GetAgentByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", r.PathValue("agent_id"), &agentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "agent_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAgentByID(w, r, agentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAgentManifestById operation middleware
func (siw *ServerInterfaceWrapper) GetAgentManifestById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", r.PathValue("agent_id"), &agentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "agent_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAgentManifestById(w, r, agentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateRun operation middleware
func (siw *ServerInterfaceWrapper) CreateRun(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateRun(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchRuns operation middleware
func (siw *ServerInterfaceWrapper) SearchRuns(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchRuns(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRun operation middleware
func (siw *ServerInterfaceWrapper) DeleteRun(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "run_id" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "run_id", r.PathValue("run_id"), &runId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRun(w, r, runId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRun operation middleware
func (siw *ServerInterfaceWrapper) GetRun(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "run_id" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "run_id", r.PathValue("run_id"), &runId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRun(w, r, runId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ResumeRun operation middleware
func (siw *ServerInterfaceWrapper) ResumeRun(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "run_id" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "run_id", r.PathValue("run_id"), &runId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResumeRun(w, r, runId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRunOutput operation middleware
func (siw *ServerInterfaceWrapper) GetRunOutput(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "run_id" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "run_id", r.PathValue("run_id"), &runId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run_id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRunOutputParams

	// ------------- Optional query parameter "block_timeout" -------------

	err = runtime.BindQueryParameter("form", true, false, "block_timeout", r.URL.Query(), &params.BlockTimeout)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "block_timeout", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunOutput(w, r, runId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRunStream operation middleware
func (siw *ServerInterfaceWrapper) GetRunStream(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "run_id" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "run_id", r.PathValue("run_id"), &runId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunStream(w, r, runId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRunThreadstate operation middleware
func (siw *ServerInterfaceWrapper) GetRunThreadstate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "run_id" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "run_id", r.PathValue("run_id"), &runId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunThreadstate(w, r, runId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateThread operation middleware
func (siw *ServerInterfaceWrapper) CreateThread(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateThread(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchThreads operation middleware
func (siw *ServerInterfaceWrapper) SearchThreads(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchThreads(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteThread operation middleware
func (siw *ServerInterfaceWrapper) DeleteThread(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "thread_id" -------------
	var threadId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "thread_id", r.PathValue("thread_id"), &threadId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "thread_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteThread(w, r, threadId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetThread operation middleware
func (siw *ServerInterfaceWrapper) GetThread(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "thread_id" -------------
	var threadId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "thread_id", r.PathValue("thread_id"), &threadId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "thread_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetThread(w, r, threadId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetThreadHistory operation middleware
func (siw *ServerInterfaceWrapper) GetThreadHistory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "thread_id" -------------
	var threadId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "thread_id", r.PathValue("thread_id"), &threadId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "thread_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetThreadHistory(w, r, threadId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetThreadState operation middleware
func (siw *ServerInterfaceWrapper) GetThreadState(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "thread_id" -------------
	var threadId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "thread_id", r.PathValue("thread_id"), &threadId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "thread_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetThreadState(w, r, threadId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/agents/search", wrapper.SearchAgents)
	m.HandleFunc("GET "+options.BaseURL+"/agents/{agent_id}", wrapper.GetAgentByID)
	m.HandleFunc("GET "+options.BaseURL+"/agents/{agent_id}/manifest", wrapper.GetAgentManifestById)
	m.HandleFunc("POST "+options.BaseURL+"/runs", wrapper.CreateRun)
	m.HandleFunc("POST "+options.BaseURL+"/runs/search", wrapper.SearchRuns)
	m.HandleFunc("DELETE "+options.BaseURL+"/runs/{run_id}", wrapper.DeleteRun)
	m.HandleFunc("GET "+options.BaseURL+"/runs/{run_id}", wrapper.GetRun)
	m.HandleFunc("POST "+options.BaseURL+"/runs/{run_id}", wrapper.ResumeRun)
	m.HandleFunc("GET "+options.BaseURL+"/runs/{run_id}/output", wrapper.GetRunOutput)
	m.HandleFunc("GET "+options.BaseURL+"/runs/{run_id}/stream", wrapper.GetRunStream)
	m.HandleFunc("GET "+options.BaseURL+"/runs/{run_id}/threadstate", wrapper.GetRunThreadstate)
	m.HandleFunc("POST "+options.BaseURL+"/threads", wrapper.CreateThread)
	m.HandleFunc("POST "+options.BaseURL+"/threads/search", wrapper.SearchThreads)
	m.HandleFunc("DELETE "+options.BaseURL+"/threads/{thread_id}", wrapper.DeleteThread)
	m.HandleFunc("GET "+options.BaseURL+"/threads/{thread_id}", wrapper.GetThread)
	m.HandleFunc("GET "+options.BaseURL+"/threads/{thread_id}/history", wrapper.GetThreadHistory)
	m.HandleFunc("GET "+options.BaseURL+"/threads/{thread_id}/state", wrapper.GetThreadState)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
